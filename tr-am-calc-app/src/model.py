import math
from dataclasses import dataclass, replace

# from typing import Callable

@dataclass(frozen=True, slots=True)
class TrofeoAmicizia:
    participants: int
    participation_price: float
    participation_medal_price: float
    gadget_price: float

    categories: int
    podiums_for_speciality_each_category: int
    average_podium_medal_price: float
    average_cup_price: float

    available_coaches: int
    coaches_for_round: dict
    coaches_salary_for_round: float
    judges_for_round: dict
    judges_salary_for_round: float

    food_cost: float

    photos_per_atlete: float
    profit_per_photo: float

    def __post_init__(self):
        if self.participants <= 1:
            raise ValueError("participants must be > 0")

    # Income
    @property
    def _registration_sales(self) -> float:
        return self.participants * self.participation_price

    @property
    def _tot_photos_exp(self) -> float:
        return self.participants * self.photos_per_atlete

    @property
    def _photo_sales(self) -> float:
        return self._tot_photos_exp * self.profit_per_photo

    @property
    def revenue(self) -> float:
        return self._registration_sales + self._photo_sales

    # Workers cost
    @property
    def _workers_cost(self) -> float:
        workers_cost_acc = 0
        for workers in self.coaches_for_round.values():
            workers_cost_acc += workers * self.coaches_salary_for_round
        return workers_cost_acc

    @property
    def _judges_cost(self) -> float:
        judges_cost_acc = 0
        for judges in self.judges_for_round.values():
            judges_cost_acc += judges * self.judges_salary_for_round
        return judges_cost_acc

    @property
    def total_workers_cost(self) -> float:
        return self._judges_cost + self._workers_cost

    # Costs for the awarding
    @property
    def _all_cups_cost(self) -> float:
        return (self.average_cup_price * 3
                * self.categories
                )

    @property
    def _all_medals_podiums_cost(self) -> float:
        return (self.podiums_for_speciality_each_category
                * self.categories
                * self.average_podium_medal_price * 3
                )

    @property
    def total_podium_cost(self) -> float:
        return self._all_cups_cost + self._all_medals_podiums_cost

    # Costs of things to give to everyone
    @property
    def _participation_medals_cost(self) -> float:
        return self.participation_medal_price * self.participants

    @property
    def _gadget_cost(self) -> float:
        return self.participants * self.gadget_price

    @property
    def awards_cost(self) -> float:
        return (self.total_podium_cost
                + self._gadget_cost
                + self._participation_medals_cost
                )

    # Aggregation
    @property
    def variable_costs(self) -> float:
        return self.awards_cost

    @property
    def fixed_costs(self) -> float:
        return self.total_workers_cost + self.food_cost

    @property
    def total_costs(self) -> float:
        return self.variable_costs + self.fixed_costs

    @property
    def profit(self) -> float:
        return self.revenue - self.total_costs

    # KPI
    def cost_per_participant(self) -> float:
        """
        Average total cost per athlete.

        - Più è basso, meglio è: indica quanto spendi in media per ogni iscritto.
        - Confrontalo con il prezzo d’iscrizione; se il costo è vicino o superiore al
          prezzo, l’evento è in pareggio o in perdita su ogni partecipante.
        """
        return self.total_costs / self.participants

    def profit_per_participant(self) -> float:
        """
        Net profit generated by each athlete.

        - Valore positivo ⇒ ogni iscritto aggiunge € all’utile complessivo.
        - Valore negativo ⇒ ogni atleta diluisce o erode il profitto.
        """
        return self.profit / self.participants

    def contribution_margin_per_participant(self) -> float:
        """
        Revenue minus variable costs for one participant.

        - Somma che ogni iscritto contribuisce alla copertura dei costi fissi.
        - Se è elevato, bastano pochi partecipanti per andare in pareggio;
          se ≤0, il modello di business è insostenibile.
        """
        return ((self.revenue - self.variable_costs) /
                self.participants)

    def profit_margin_pct(self) -> float:
        """
        Overall profit as a share of total turnover (0–1 scale).

        0.25 significa che trattieni il 25% di ogni euro incassato.
        Confrontalo con edizioni precedenti o benchmark di settore;
        un margine in calo indica costi in crescita o ricavi in discesa.
        """
        return self.profit / self.revenue if self.revenue else 0.0

    def break_even_participants(self) -> int:
        """
        Minimum number of athletes required to hit break‑even
        (rounded up to the next integer).

        Se il risultato è, ad esempio, 280, servono almeno 280 iscrizioni paganti affinché
        l’evento non vada in perdita.
        math.inf significa che il margine di contribuzione è
        ≤0—raggiungere il pareggio è impossibile con i prezzi/costi attuali.
        """
        m = self.contribution_margin_per_participant()
        return math.inf if m <= 0 else math.ceil(self.fixed_costs / m)

    def variable_to_fixed_ratio(self) -> float:
        """
        Ratio of variable costs to fixed costs.

        1 significa che i costi variabili dominano (rischio più basso se cala la partecipazione).
        <1 indica una struttura a costi fissi elevata; i profitti allora oscilleranno fortemente al
         variare del numero di partecipanti.
        """
        return self.variable_costs / self.fixed_costs if self.fixed_costs else math.inf

    def average_revenue_per_participant(self) -> float:
        """
        ARPP – Average Revenue Per Participant.

        Confronta questo valore con il tuo costo per partecipante (CPP) e con i dati del settore.
        Un ARPP in aumento indica una buona strategia di up-selling (es. foto, merchandising) o un
        incremento dei prezzi.
        """
        return self.revenue / self.participants

    def photo_revenue_ratio(self) -> float:
        """
        Ratio of photo revenue to total revenue.

        Valori vicini a 1 (100%) indicano che le foto rappresentano la principale fonte di ricavo,
        mentre valori prossimi a 0 indicano che il fatturato è trainato dalle iscrizioni (o da altre fonti).
        """
        return self._photo_sales / self.revenue if self.revenue else 0.0

    def dprofit_dparticipants(self) -> float:
        """
        Approximate marginal profit of adding one more participant.

        Un valore positivo indica quanti € l’evento guadagna per ogni atleta aggiuntivo.
        Se è negativo, aggiungere partecipanti riduce il profitto.
        """
        # Guard against unrealistic edge cases
        if self.participants <= 0:
            return 0.0
        # Create a clone with one extra participant
        clone = replace(self, participants=self.participants + 1)
        return clone.profit - self.profit

    def d2profit_dparticipants2(self) -> float:
        """
        Second discrete derivative of profit with respect to participants:
        Δ²Profit = Profit(n+1) − 2·Profit(n) + Profit(n−1)

        - Valore < 0  ⇒ marginal profit diminuisce con ogni atleta in più
                        (rendimenti decrescenti).
        - Valore ≈ 0 ⇒ marginal profit quasi costante.
        - Valore > 0  ⇒ marginal profit cresce al crescere degli iscritti
                        (economie di scala).

        Per participants ≤ 1 il valore non è definito; ritorna 0.0.
        """
        if self.participants <= 1:
            return 0.0
        # profit at n, n+1 and n-1 participants
        p_n = self.profit
        p_np1 = replace(self, participants=self.participants + 1).profit
        p_nm1 = replace(self, participants=self.participants - 1).profit
        return p_np1 - 2 * p_n + p_nm1
